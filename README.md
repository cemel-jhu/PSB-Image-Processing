# PSB Image Processing :movie_camera:

[![DOI:10.1000/000-0-000-00000-0_00](https://zenodo.org/badge/DOI/10.1000/000-0-000-00000-0_00.svg)](#)
[![Craedl data](https://img.shields.io/badge/craedl-el--awady--lab/PSB%20Investigation%20Project-3f51b5?logo=data:image/png;base64,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)](https://craedl.org/project/3999350)

This repository provides some of the source code used for [insert paper
here](#).  Source images and results may be available upon contact or in
[craedl repository](https://craedl.org/project/3999350), as they are too
large to host on github.

---

This research was sponsored by the U.S. Air Force Office of Scientific Research
(AFOSR) under grant \# FA9550-18-1-0071. This material is based upon work
supported by the National Science Foundation Graduate Research Fellowship under
Grant DGE-1746891. The authors recognize Dr. Craig Johnson at Drexel
University for his help with transmission electron microscopy. The authors also
appreciate insightful discussions with Professor H¨ael Mughrabi of
Erlangen-N¨urnberg University in Germany and Professor Jaroslav Pol´ak of the
Institute of Physics of Materials at Academy of Sciences of the Czech Republic

---

Provided a video of micro pillars being loaded, this code determines the rate
of PSB propagation, and the embryonic size of PSBs.

## Installation

Install this package via pip i.e `pip install git+git://github.com/cemel-jhu/PSB-Image-Processing@master`.
Alternatively, clone this repository and use `pip install .`

To install updates run `pip install git+git://github.com/cemel-jhu/PSB-Image-Processing@master --upgrade`.

## Usage

Interactively run the notebook with `jupyter notebook .`, or import needed functions from the module:
```python
import PSBProcessing as psm
...
```

To run bulk studies, implement the `parameter_study.py` script provided. Its usage is as follows:

```text
usage: parameter_study.py [-h] [--study STUDY] --parameter PARAMETER N [N ...]
parameter_study.py: The following arguments are required: N, --parameter
```

For example: `python parameter_study.py --study=sigma_variation
--parameter=sigma 0.35 0.65 1` runs a parameter study on the filtering
hyperparameter `sigma`. For other parameters see below.

## Analysis Variables
The study of a given PSB band is performed based on these global variables.
Align these parameters with your work.
```python
# Run specific variables
experiment = 32  # The experiment number. Images for this experiment should be in folder {experiment}/
band = 3  # The band to examine within the experiment
export_gifs = True  # Whether gifs should be exported
interactive = True  # Whether interactive parts of the script should be run.
recompute = False  # Forces recomputation. Warning, will potentially overwrite
                   # other variables.

# Experiment specific variables. These will be overwritten
# if the experiment has already been analyzed.
scale = 768 / 40.27  # Pixels to um ratio.
frequency = 75  # The frequency of loading in Hz
direction = 2. / 3  # The slope of the PSBs in the experiment relative to the image.
                    # Seemingly allows for margin of error.
beam_height = 600  # In pixels
beam_width = 180  # in pixels
flip = True  # All PSB slopes should be positive. If the slope is negative, a
             # reflection is performed on the picture.

# Band specific variables
start = 0  # The start offset of a given band.
width = beam_height  # The width of the given band.

# New experiment specific variables. These values will be ignored
# unless no records exist for the given variable.
# Image loading specific variables.
resize = 0  # Scale factor by which the image should be resized. Set 0 for no resizing.
borders = [50, 140, 30, 40]  # Left, Right, Top, Bottom.
                             # Cropping margins for the processed images.
margin_x = [20, 3]  # The margin to provide a partially cropped beam,
                    # when determining how to crop the height

# Event capture specific variables.
time_margin = 15  # How much of the video to ignore at the beginning and end
sigma = 0.65  # Smoothing deviation for filtering procedures
```

## Velocity Determination
The general procedure for velocity determination is as follows:
```python
# Each frame is warped along the PSB direction. In practice this was
# implemented iteratively with `scipy.interpolate.interp2d`.
warped_frames = []
for frame in frames:
  warped_frames += warp(frame)

# Each frame is cropped to a particular PSB at the discretion of the researcher.
canidate_psb = []
for frame in warped_frames:
  canidate_psb += crop(frame)

# The time cube of dimension [time, width, height]
# is flipped to [height, width, time].
canidate_profile_source = flip(canidate_psb)

# Iterate over and extract the profiles for each time slice of size
# [width, height].
profiles = []
for slice in canidate_profile_source:
  profiles += detect_profile(slice)

# Use one of the aggregation methods to extract a representative profile.
velocity_profile = aggregate_profiles(profile)
```

## Embryonic Width detection
The general procedure for embryonic width determination is as follows:
```python
potential_embryo = []
for cycle, displacement in sorted(profile):
  potential_embryo += [(cycle, displacement)]
  qq_fits += [qq_fit(potential_embryo.displacements)]

embyro = potential_embryo[:argmin(qq_fits)]
embyro_start = min(embryo.displacements)
embyro_end = max(embryo.displacements)
embryo_length = embryo_end - embyro_start
```
